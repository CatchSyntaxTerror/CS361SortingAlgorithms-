# 📊 CS361 Sorting Algorithms Project

Youssef Amin, Finn Ellis, Nicholas Chacon  
*University of New Mexico — Spring 2025*

This project was created for CS361: Data Structiures and Algorithms.  
It implements and benchmarks four sorting algorithms across multiple input sizes and data types.  
The goal: compare performance, complexity, and scalability — from `2^20` to `2^30` elements.

---

## ✨ Implemented Sorting Algorithms

- 🪜 **Quad-Heap Sort (QHS)**: Custom 4-ary heap-based sorting implementation  
- 🔀 **Randomized Quick Sort (RQS)**: QuickSort with randomly chosen pivots  
- 🍰 **3-Way Merge Sort (MS3)**: Recursive merge sort with three-way division  
- 🧵 **Tim Sort (TS)**: Hybrid merge/insertion sort (inspired by Java/Python’s default)

---

## 🧪 Benchmarking Overview

Benchmarks are run using a custom script and JAR tool on datasets of size `2^n`, where `n` ranges from 20 to 30.

Benchmarks are performed on:
- 🔢 Integer datasets (`ints`)
- 🔬 Double-precision datasets (`doubles`)

---

## 🚀 How to Run

### 1. 📁 Setup Your Environment
- Make sure you're using a Unix-like shell (Linux, macOS, WSL, etc.)
- Java must be installed

### 2. 📂 Create a `Data` Directory

\`\`\`bash
mkdir Data
\`\`\`

### 3. 📈 Generate Datasets

\`\`\`bash
java -jar Benchmarker.jar -generate 20 30
\`\`\`

This creates files like `ints_20.txt` and `doubles_25.txt` inside the `Data` folder.

### 4. 🧪 Run Benchmarks

To benchmark all algorithms on `ints_20.txt`:

\`\`\`bash
./benchmark.sh ints 20
\`\`\`

To benchmark a range (e.g., 2^22 to 2^25):

\`\`\`bash
./benchmark.sh doubles 22 25
\`\`\`

---

## 📁 File Structure

- `Benchmarker.jar`: Core benchmarking logic and CLI tool  
- `benchmark.sh`: Shell script to run batch benchmarks on datasets  
- `Data/`: Folder containing input datasets (generated by the JAR)  
- `src/`: Java source code for all four sorting algorithms  
- `results/`: Output folder for performance logs and runtime measurements  

---

## 🧠 Notes

- Input/output (I/O) time is excluded from benchmark timing to isolate algorithm performance  
- Data is loaded into memory before timing begins  
- Algorithms were all implemented in **Java** using only primitive data structures (per project guidelines)

---

## 📚 Project Context

This project was assigned as the final in CS361 at UNM.  
The purpose was to explore implementation complexity, runtime efficiency, and algorithmic tradeoffs across real-world data scales.  

Each team member contributed specific algorithms, testing, and reporting sections as described in the final report.

---

## 🛠️ Extra Credit

We implemented additional sorting capabilities for structured data with multiple sorting keys (e.g., sorting records by GPA then name) to demonstrate stability and adaptability.

---

## 👥 Authors

- **Youssef Amin** — Quad Heap Sort, benchmark scripting  
- **Finn Ellis** — 3-Way Merge Sort, documentation  
- **Nicholas Chacon** — Randomized Quick Sort, test generation  
