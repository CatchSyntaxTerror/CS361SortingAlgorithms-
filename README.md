# ğŸ“Š CS361 Sorting Algorithms Project

Youssef Amin, Finn Ellis, Nicholas Chacon  
*University of New Mexico â€” Spring 2025*

This project was created for CS361: Data Structiures and Algorithms.  
It implements and benchmarks four sorting algorithms across multiple input sizes and data types.  
The goal: compare performance, complexity, and scalability â€” from `2^20` to `2^30` elements.

---

## âœ¨ Implemented Sorting Algorithms

- ğŸªœ **Quad-Heap Sort (QHS)**: Custom 4-ary heap-based sorting implementation  
- ğŸ”€ **Randomized Quick Sort (RQS)**: QuickSort with randomly chosen pivots  
- ğŸ° **3-Way Merge Sort (MS3)**: Recursive merge sort with three-way division  
- ğŸ§µ **Tim Sort (TS)**: Hybrid merge/insertion sort (inspired by Java/Pythonâ€™s default)

---

## ğŸ§ª Benchmarking Overview

Benchmarks are run using a custom script and JAR tool on datasets of size `2^n`, where `n` ranges from 20 to 30.

Benchmarks are performed on:
- ğŸ”¢ Integer datasets (`ints`)
- ğŸ”¬ Double-precision datasets (`doubles`)

---

## ğŸš€ How to Run

### 1. ğŸ“ Setup Your Environment
- Make sure you're using a Unix-like shell (Linux, macOS, WSL, etc.)
- Java must be installed

### 2. ğŸ“‚ Create a `Data` Directory

\`\`\`bash
mkdir Data
\`\`\`

### 3. ğŸ“ˆ Generate Datasets

\`\`\`bash
java -jar Benchmarker.jar -generate 20 30
\`\`\`

This creates files like `ints_20.txt` and `doubles_25.txt` inside the `Data` folder.

### 4. ğŸ§ª Run Benchmarks

To benchmark all algorithms on `ints_20.txt`:

\`\`\`bash
./benchmark.sh ints 20
\`\`\`

To benchmark a range (e.g., 2^22 to 2^25):

\`\`\`bash
./benchmark.sh doubles 22 25
\`\`\`

---

## ğŸ“ File Structure

- `Benchmarker.jar`: Core benchmarking logic and CLI tool  
- `benchmark.sh`: Shell script to run batch benchmarks on datasets  
- `Data/`: Folder containing input datasets (generated by the JAR)  
- `src/`: Java source code for all four sorting algorithms  
- `results/`: Output folder for performance logs and runtime measurements  

---

## ğŸ§  Notes

- Input/output (I/O) time is excluded from benchmark timing to isolate algorithm performance  
- Data is loaded into memory before timing begins  
- Algorithms were all implemented in **Java** using only primitive data structures (per project guidelines)

---

## ğŸ“š Project Context

This project was assigned as the final in CS361 at UNM.  
The purpose was to explore implementation complexity, runtime efficiency, and algorithmic tradeoffs across real-world data scales.  

Each team member contributed specific algorithms, testing, and reporting sections as described in the final report.

---

## ğŸ› ï¸ Extra Credit

We implemented additional sorting capabilities for structured data with multiple sorting keys (e.g., sorting records by GPA then name) to demonstrate stability and adaptability.

---

## ğŸ‘¥ Authors

- **Youssef Amin** â€” Quad Heap Sort, benchmark scripting  
- **Finn Ellis** â€” 3-Way Merge Sort, documentation  
- **Nicholas Chacon** â€” Randomized Quick Sort, test generation  
